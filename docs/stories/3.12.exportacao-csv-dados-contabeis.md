# Story 3.12: Exportação de Dados Contábeis Genéricos para CSV

## Status

**Draft** (2025-12-27)

---

## Story

**As a** CONTADOR,
**I want** exportar dados contábeis genéricos para arquivo CSV,
**so that** eu possa fazer backup, análises externas ou compartilhar com outros sistemas.

---

## Acceptance Criteria

1. Endpoint `GET /api/v1/accounting-data/export` criado (CONTADOR com header X-Company-Id):
   - Query param obrigatório: `?fiscalYear=2024`
   - Query param opcional: `?competenciaInicio=2024-01-01` e `?competenciaFim=2024-12-31`
   - Response: arquivo CSV para download (Content-Type: text/csv; charset=UTF-8)

2. Use case `ExportAccountingDataUseCase` implementado:
   - Busca todos dados contábeis da empresa no contexto + fiscalYear
   - Se competenciaInicio/Fim fornecidos: filtra por range de competência
   - Gera arquivo CSV com formato:
     ```
     accountCode;accountName;competencia;debitAmount;creditAmount;balance;description
     1.1.01.001;Caixa;2024-01-31;1000.00;500.00;5500.00;Lançamento Janeiro
     ```
   - Header Content-Disposition: `attachment; filename="accounting-data-{companyId}-{fiscalYear}.csv"`

3. Formato do arquivo gerado:
   - **Separador**: `;` (ponto e vírgula)
   - **Encoding**: UTF-8
   - **Linha 1**: Header
   - **Linhas 2+**: Dados, ordenados por accountCode ASC, competencia ASC
   - **Números**: formato `1000.00` (ponto decimal, 2 casas)
   - **Datas**: formato ISO 8601 (YYYY-MM-DD)

4. Validações:
   - fiscalYear obrigatório
   - Se competenciaInicio fornecido sem competenciaFim: erro 400
   - Se competenciaFim < competenciaInicio: erro 400

5. Response:
   - 200 OK com arquivo CSV
   - 400 Bad Request se validações falharem
   - 404 Not Found se nenhum dado encontrado

6. Teste valida:
   - Exportação gera arquivo válido com header correto
   - Arquivo pode ser reimportado sem erros (round-trip)
   - Filtro por range de competência funciona
   - Encoding UTF-8 preserva caracteres especiais
   - Arquivo com 10.000 linhas é gerado em < 10s

---

## Tasks / Subtasks

- [ ] Criar use case ExportAccountingDataUseCase (AC: 2, 3, 4)
  - [ ] Buscar dados contábeis por empresa + fiscalYear
  - [ ] Aplicar filtro de range de competência (opcional)
  - [ ] Gerar CSV com Apache Commons CSV
  - [ ] Ordenar por accountCode ASC, competencia ASC
  - [ ] Formatar números (2 casas decimais)
  - [ ] Formatar datas (ISO 8601)

- [ ] Criar endpoint (AC: 1)
  - [ ] GET /api/v1/accounting-data/export
  - [ ] Query params: fiscalYear, competenciaInicio, competenciaFim
  - [ ] Validar header X-Company-Id
  - [ ] Response com Content-Type: text/csv
  - [ ] Header Content-Disposition com filename

- [ ] Implementar validações (AC: 4, 5)
  - [ ] fiscalYear obrigatório
  - [ ] competenciaInicio/Fim validação
  - [ ] 404 se nenhum dado encontrado

- [ ] Criar testes de integração (AC: 6)
  - [ ] Exportação gera arquivo válido
  - [ ] Round-trip (exportar → reimportar)
  - [ ] Filtro de range funciona
  - [ ] Encoding UTF-8
  - [ ] Performance: 10.000 linhas em < 10s

---

## Dev Notes

### Endpoint REST

**GET /api/v1/accounting-data/export?fiscalYear=2024**

**Response Headers:**
```
Content-Type: text/csv; charset=UTF-8
Content-Disposition: attachment; filename="accounting-data-123-2024.csv"
```

**Response Body (CSV):**
```csv
accountCode;accountName;competencia;debitAmount;creditAmount;balance;description
1.1.01.001;Caixa;2024-01-31;1000.00;500.00;5500.00;Lançamento Janeiro
1.1.01.001;Caixa;2024-02-29;2000.00;1500.00;6000.00;Lançamento Fevereiro
1.1.02.001;Bancos Conta Movimento;2024-01-31;50000.00;25000.00;125000.50;Movimentação Bancária
```

### Geração do CSV

```java
@Service
public class ExportAccountingDataUseCase {

    public byte[] execute(Long companyId, Integer fiscalYear,
                          LocalDate competenciaInicio, LocalDate competenciaFim) {
        // Buscar dados
        List<AccountingData> data = accountingDataRepository
            .findByCompanyIdAndFiscalYear(companyId, fiscalYear);

        // Aplicar filtro de range (se fornecido)
        if (competenciaInicio != null && competenciaFim != null) {
            data = data.stream()
                .filter(d -> !d.getCompetencia().isBefore(competenciaInicio) &&
                            !d.getCompetencia().isAfter(competenciaFim))
                .collect(Collectors.toList());
        }

        // Ordenar
        data.sort(Comparator
            .comparing(AccountingData::getAccountCode)
            .thenComparing(AccountingData::getCompetencia));

        // Gerar CSV
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        try (OutputStreamWriter writer = new OutputStreamWriter(outputStream, StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT
                 .withDelimiter(';')
                 .withHeader("accountCode", "accountName", "competencia",
                             "debitAmount", "creditAmount", "balance", "description"))) {

            for (AccountingData item : data) {
                csvPrinter.printRecord(
                    item.getAccountCode(),
                    item.getAccountName(),
                    item.getCompetencia().toString(),
                    formatDecimal(item.getDebitAmount()),
                    formatDecimal(item.getCreditAmount()),
                    formatDecimal(item.getBalance()),
                    item.getDescription()
                );
            }
        }

        return outputStream.toByteArray();
    }

    private String formatDecimal(BigDecimal value) {
        if (value == null) return "";
        return String.format("%.2f", value);
    }
}
```

### Round-trip Test

```java
@Test
void shouldExportAndReimportWithoutErrors() {
    // Criar dados originais
    createAccountingData(100);

    // Exportar
    byte[] csvBytes = exportUseCase.execute(companyId, 2024, null, null);

    // Limpar dados
    deleteAllAccountingData();

    // Reimportar
    MultipartFile file = new MockMultipartFile("file", "export.csv",
        "text/csv", csvBytes);
    ImportAccountingDataResponse response = importUseCase.execute(file, 2024, false);

    // Validar
    assertThat(response.getProcessedLines()).isEqualTo(100);
    assertThat(response.getErrors()).isEmpty();
}
```

### Validações de Query Params

- **fiscalYear**: obrigatório
- **competenciaInicio**: opcional, mas se fornecido, competenciaFim também deve ser
- **competenciaFim**: opcional, mas deve ser >= competenciaInicio

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-27 | 1.0 | Story criada a partir do Epic 3 | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used
*A ser preenchido durante desenvolvimento*

### Debug Log References
*A ser preenchido durante desenvolvimento*

### Completion Notes List
*A ser preenchido durante desenvolvimento*

### File List
*A ser preenchido durante desenvolvimento*

---

## QA Results
*A ser preenchido após revisão de QA*
