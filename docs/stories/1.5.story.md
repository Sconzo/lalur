# Story 1.5: Configuração Spring Security & JWT

## Status

**Done**

## Story

**Como** desenvolvedor,
**Eu quero** Spring Security configurado com autenticação JWT,
**Para que** endpoints protegidos exijam token válido e role apropriado.

## Acceptance Criteria

1. Dependência `jjwt` (Java JWT) adicionada ao `pom.xml`
2. Classe `JwtTokenProvider` criada em `infrastructure/security/`:
   - `generateAccessToken(String email, UserRole role)` - expira em 15min
   - `generateRefreshToken(String email)` - expira em 7 dias
   - `validateToken(String token)` - retorna boolean
   - `getEmailFromToken(String token)`
   - `getRoleFromToken(String token)`
   - Secret key configurável via variável de ambiente `JWT_SECRET`
3. Classe `JwtAuthenticationFilter` (extends OncePerRequestFilter) criada:
   - Extrai token do header `Authorization: Bearer {token}`
   - Valida token via `JwtTokenProvider`
   - Popula `SecurityContext` com `UsernamePasswordAuthenticationToken`
4. Classe `SecurityConfig` criada com:
   - `@EnableWebSecurity` e `@EnableMethodSecurity`
   - BCryptPasswordEncoder bean (strength 12)
   - SecurityFilterChain configurado:
     - `/api/v1/auth/**` permitAll
     - `/api/v1/actuator/health` permitAll
     - `/swagger-ui/**`, `/v3/api-docs/**` permitAll
     - Todos outros endpoints require authentication
   - `JwtAuthenticationFilter` adicionado antes de UsernamePasswordAuthenticationFilter
5. Endpoint de health check `/api/v1/actuator/health` acessível sem autenticação
6. Endpoints protegidos retornam 401 Unauthorized se token ausente/inválido
7. Teste valida que token válido permite acesso a endpoints protegidos
8. Teste valida que token expirado é rejeitado

## Tasks / Subtasks

- [ ] **Task 1: Adicionar Dependência JWT** (AC: 1)
  - [ ] Adicionar ao pom.xml:
    ```xml
    <dependency>
        <groupId>com.auth0</groupId>
        <artifactId>java-jwt</artifactId>
        <version>4.4.0</version>
    </dependency>
    ```

- [ ] **Task 2: Criar JwtTokenProvider** (AC: 2)
  - [ ] Criar `infrastructure/security/JwtTokenProvider.java`
  - [ ] Anotar com `@Component`
  - [ ] Injetar `@Value("${jwt.secret}")` e expirations
  - [ ] Implementar `generateAccessToken()` usando HMAC256
  - [ ] Implementar `generateRefreshToken()` (sem role claim)
  - [ ] Implementar `validateToken()` com try-catch JWT exceptions
  - [ ] Implementar `getEmailFromToken()` e `getRoleFromToken()`

- [ ] **Task 3: Criar JwtAuthenticationFilter** (AC: 3)
  - [ ] Criar `infrastructure/security/JwtAuthenticationFilter.java`
  - [ ] Estender `OncePerRequestFilter`
  - [ ] Injetar `JwtTokenProvider`
  - [ ] Implementar `doFilterInternal()`:
    - Extrair token do header Authorization
    - Validar token
    - Criar `UsernamePasswordAuthenticationToken` com authorities
    - Setar no SecurityContext
    - Chamar `filterChain.doFilter()`

- [ ] **Task 4: Criar SecurityConfig** (AC: 4)
  - [ ] Criar `infrastructure/config/SecurityConfig.java`
  - [ ] Anotar com `@Configuration`, `@EnableWebSecurity`, `@EnableMethodSecurity`
  - [ ] Criar bean `BCryptPasswordEncoder` com strength 12
  - [ ] Criar bean `SecurityFilterChain`:
    - Desabilitar CSRF (stateless API)
    - Configurar CORS (se necessário)
    - Configurar session management: STATELESS
    - Configurar authorization rules (permitAll vs authenticated)
    - Adicionar `JwtAuthenticationFilter` antes de `UsernamePasswordAuthenticationFilter`

- [ ] **Task 5: Configurar application.yml** (AC: 2)
  - [ ] Adicionar configurações JWT:
    ```yaml
    jwt:
      secret: ${JWT_SECRET:dev-secret-key-change-in-production-minimum-256-bits}
      access-token-expiration: 900000  # 15 min
      refresh-token-expiration: 604800000  # 7 dias
    ```

- [ ] **Task 6: Criar Endpoint de Teste Protegido**
  - [ ] Criar `TestController` com endpoint `/api/v1/test/protected`
  - [ ] Anotar com `@PreAuthorize("isAuthenticated()")`
  - [ ] Retornar mensagem simples

- [ ] **Task 7: Criar Testes Unitários** (AC: 7, 8)
  - [ ] Testar `JwtTokenProvider.generateAccessToken()` e validar claims
  - [ ] Testar `JwtTokenProvider.validateToken()` com token expirado
  - [ ] Testar `JwtAuthenticationFilter` com MockMvc

- [ ] **Task 8: Criar Teste de Integração**
  - [ ] Testar acesso a endpoint protegido sem token → 401
  - [ ] Testar acesso com token válido → 200
  - [ ] Testar acesso com token expirado → 401

## Dev Notes

### Contexto de Segurança

[Source: architecture/15-Segurança.md]

**Padrões Obrigatórios:**
- JWT stateless (Auth0 java-jwt 4.4.0)
- Access token: 15 minutos
- Refresh token: 7 dias
- BCrypt strength 12
- `@PreAuthorize` em TODOS endpoints protegidos

**Gestão de Secrets:**
- Dev: `.env` (gitignored)
- Prod: Variáveis de ambiente
- NUNCA hardcodar secrets
- NUNCA logar tokens completos

### JwtTokenProvider - Implementação

```java
package br.com.lalurecf.infrastructure.security;

import br.com.lalurecf.domain.enums.UserRole;
import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.DecodedJWT;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class JwtTokenProvider {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.access-token-expiration}")
    private Long accessTokenExpiration;

    @Value("${jwt.refresh-token-expiration}")
    private Long refreshTokenExpiration;

    public String generateAccessToken(String email, UserRole role) {
        return JWT.create()
            .withSubject(email)
            .withClaim("role", role.name())
            .withIssuedAt(new Date())
            .withExpiresAt(new Date(System.currentTimeMillis() + accessTokenExpiration))
            .sign(Algorithm.HMAC256(secret));
    }

    public String generateRefreshToken(String email) {
        return JWT.create()
            .withSubject(email)
            .withIssuedAt(new Date())
            .withExpiresAt(new Date(System.currentTimeMillis() + refreshTokenExpiration))
            .sign(Algorithm.HMAC256(secret));
    }

    public boolean validateToken(String token) {
        try {
            JWT.require(Algorithm.HMAC256(secret))
                .build()
                .verify(token);
            return true;
        } catch (JWTVerificationException e) {
            return false;
        }
    }

    public String getEmailFromToken(String token) {
        DecodedJWT jwt = JWT.decode(token);
        return jwt.getSubject();
    }

    public UserRole getRoleFromToken(String token) {
        DecodedJWT jwt = JWT.decode(token);
        String role = jwt.getClaim("role").asString();
        return UserRole.valueOf(role);
    }
}
```

### JwtAuthenticationFilter - Implementação

```java
package br.com.lalurecf.infrastructure.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;

    public JwtAuthenticationFilter(JwtTokenProvider jwtTokenProvider) {
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        String authHeader = request.getHeader("Authorization");

        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);

            if (jwtTokenProvider.validateToken(token)) {
                String email = jwtTokenProvider.getEmailFromToken(token);
                String role = jwtTokenProvider.getRoleFromToken(token).name();

                SimpleGrantedAuthority authority = new SimpleGrantedAuthority("ROLE_" + role);
                UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(email, null, Collections.singletonList(authority));

                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }

        filterChain.doFilter(request, response);
    }
}
```

### SecurityConfig - Implementação

```java
package br.com.lalurecf.infrastructure.config;

import br.com.lalurecf.infrastructure.security.JwtAuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/actuator/health").permitAll()
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
```

### Testing

**Teste Unitário - JwtTokenProvider:**
```java
@DisplayName("JwtTokenProvider - Testes Unitários")
class JwtTokenProviderTest {

    @Test
    @DisplayName("Deve gerar access token válido com claims corretos")
    void shouldGenerateValidAccessToken() {
        // Test implementation
    }

    @Test
    @DisplayName("Deve rejeitar token expirado")
    void shouldRejectExpiredToken() {
        // Test implementation
    }
}
```

**Teste de Integração:**
```java
@DisplayName("Security - Testes de Integração")
class SecurityIntegrationTest extends IntegrationTestBase {

    @Test
    @DisplayName("Deve retornar 401 ao acessar endpoint protegido sem token")
    void shouldReturn401WithoutToken() {
        // Test implementation
    }

    @Test
    @DisplayName("Deve retornar 200 ao acessar endpoint protegido com token válido")
    void shouldReturn200WithValidToken() {
        // Test implementation
    }
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-25 | 1.0 | Story criada do Epic 01 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

**Model:** Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)
**Agent Type:** Developer (James)
**Date:** 2025-11-09

### Debug Log References

**Implementation:**
- JWT dependency already present in pom.xml from Story 1.1
- JWT configuration already present in application-dev.yml and application-prod.yml
- All security components created successfully
- Spring Security configured with stateless session management
- JWT filter integrated into security filter chain
- BCrypt configured with strength 12
- Unit and integration tests created with full coverage

### Completion Notes

All 8 tasks completed successfully:

1. **JWT Dependency:** Already present in pom.xml (auth0/java-jwt 4.4.0)
2. **JwtTokenProvider:** Created component with methods for generating access/refresh tokens, validating tokens, and extracting claims (email and role)
3. **JwtAuthenticationFilter:** Created filter extending OncePerRequestFilter to intercept requests, validate JWT, and populate SecurityContext
4. **SecurityConfig:** Created configuration with @EnableWebSecurity and @EnableMethodSecurity, BCrypt strength 12, stateless sessions, authorization rules (permitAll for auth/actuator/swagger, authenticated for others)
5. **JWT Configuration:** Already present in application-dev.yml (secret, access token 15min, refresh token 7 days)
6. **Test Protected Endpoint:** Created TestController with /api/v1/test/protected (authenticated) and /api/v1/test/admin (ROLE_ADMIN)
7. **Unit Tests:** Created JwtTokenProviderTest with 5 test cases (generate valid token, validate claims, reject expired token, reject invalid signature, extract email/role)
8. **Integration Tests:** Created SecurityIntegrationTest with 6 test cases using MockMvc (401 without token, 200 with valid token, 401 with invalid token, 403 without admin role, 200 with admin role, health check without auth)

**Important Notes:**
- All acceptance criteria met
- Stateless authentication using JWT (no sessions)
- Access tokens expire in 15 minutes
- Refresh tokens expire in 7 days
- BCrypt strength 12 for password hashing
- Security filter chain properly configured
- @PreAuthorize annotations work correctly
- Public endpoints: /api/v1/auth/**, /api/v1/actuator/health, /swagger-ui/**, /v3/api-docs/**
- All other endpoints require authentication
- Role-based authorization working (ROLE_ADMIN, ROLE_CONTADOR)
- JWT filter extracts token from "Authorization: Bearer {token}" header
- SecurityContext populated with UsernamePasswordAuthenticationToken containing email and authorities

**Security Configuration:**
- CSRF disabled (stateless API)
- Session management: STATELESS
- JWT filter added before UsernamePasswordAuthenticationFilter
- Authority format: "ROLE_" + role (e.g., "ROLE_ADMIN", "ROLE_CONTADOR")

**Test Coverage:**
- 5 unit tests for JwtTokenProvider
- 6 integration tests for security endpoints
- All authentication and authorization scenarios covered

### File List

**Created Files:**
- `src/main/java/br/com/lalurecf/infrastructure/security/JwtTokenProvider.java` - JWT token generation and validation
- `src/main/java/br/com/lalurecf/infrastructure/security/JwtAuthenticationFilter.java` - JWT authentication filter
- `src/main/java/br/com/lalurecf/infrastructure/config/SecurityConfig.java` - Spring Security configuration
- `src/main/java/br/com/lalurecf/infrastructure/adapter/in/rest/TestController.java` - Test endpoints for security validation
- `src/test/java/br/com/lalurecf/infrastructure/security/JwtTokenProviderTest.java` - Unit tests (5 test cases)
- `src/test/java/br/com/lalurecf/infrastructure/adapter/in/rest/SecurityIntegrationTest.java` - Integration tests (6 test cases)

**JWT Token Structure:**
- Access Token Claims: subject (email), role (UserRole enum), issuedAt, expiresAt
- Refresh Token Claims: subject (email), issuedAt, expiresAt
- Algorithm: HMAC256
- Secret: Configurable via ${jwt.secret} environment variable

## QA Results

*Esta seção será preenchida pelo QA Agent após implementação.*
