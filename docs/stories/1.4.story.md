# Story 1.4: Entidade User e Repository

## Status

**Done**

## Story

**Como** desenvolvedor,
**Eu quero** entidade User com repository JPA implementando port,
**Para que** possamos persistir usuários no banco de dados seguindo arquitetura hexagonal.

## Acceptance Criteria

1. Entidade JPA `UserEntity` criada em `infrastructure/adapter/out/persistence/entity/` estendendo `BaseEntity`:
   - `@Column(name="primeiro_nome", nullable=false) String firstName` (nome)
   - `@Column(name="sobrenome", nullable=false) String lastName` (sobrenome)
   - `@Column(nullable=false, unique=true) String email` (usado para login)
   - `@Column(name="senha", nullable=false) String password` (hash BCrypt)
   - `@Enumerated(STRING) @Column(name="funcao", nullable=false) UserRole role` (ADMIN ou CONTADOR)
   - `@Column(name="deve_mudar_senha", nullable=false) Boolean mustChangePassword` - default true
   - **Nota:** Tabela de banco = `tb_usuario`, colunas em snake_case conforme ADR-001
2. Enum `UserRole` criado com valores ADMIN e CONTADOR
3. Interface `UserRepositoryPort` criada em `application/port/out/`:
   - `Optional<User> findByEmail(String email)`
   - `User save(User user)`
   - `Optional<User> findById(Long id)`
   - `List<User> findAll()`
   - Métodos seguem convenção de domain objects (não JPA entities)
4. Interface `UserJpaRepository` criada estendendo `JpaRepository<UserEntity, Long>`:
   - `Optional<UserEntity> findByEmail(String email)`
5. Classe `UserRepositoryAdapter` implementa `UserRepositoryPort` usando `UserJpaRepository` e MapStruct para conversão Entity ↔ Domain
6. Model `User` (domain) criado em `domain/model/` como POJO puro sem annotations JPA
7. Mapper MapStruct `UserMapper` criado para conversão `UserEntity` ↔ `User`
8. Teste de integração (TestContainers) valida:
   - Salvar usuário e recuperar por email
   - Unique constraint em email (tentativa de duplicata lança exception)
   - Soft delete funciona corretamente (status INACTIVE)

## Tasks / Subtasks

- [ ] **Task 1: Criar Enum UserRole** (AC: 2)
  - [ ] Criar `domain/enums/UserRole.java`:
    ```java
    public enum UserRole {
        ADMIN,
        CONTADOR
    }
    ```

- [ ] **Task 2: Criar Domain Model User** (AC: 6)
  - [ ] Criar `domain/model/User.java` como POJO puro (sem annotations JPA)
  - [ ] Adicionar campos: `id`, `firstName`, `lastName`, `email`, `password`, `role`, `mustChangePassword`, `status`, campos auditoria
  - [ ] Adicionar construtor, getters, setters
  - [ ] Usar Lombok `@Data`, `@Builder`, `@NoArgsConstructor`, `@AllArgsConstructor`

- [ ] **Task 3: Criar JPA Entity UserEntity** (AC: 1)
  - [ ] Criar `infrastructure/adapter/out/persistence/entity/UserEntity.java`
  - [ ] Estender `BaseEntity`
  - [ ] Anotar com `@Entity` e `@Table(name = "tb_usuario")`
  - [ ] Mapear campos com `@Column(name="...")` conforme ADR-001:
    ```java
    @Column(name = "primeiro_nome", nullable = false)
    private String firstName;

    @Column(name = "sobrenome", nullable = false)
    private String lastName;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(name = "senha", nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(name = "funcao", nullable = false)
    private UserRole role;

    @Column(name = "deve_mudar_senha", nullable = false)
    private Boolean mustChangePassword = true;
    ```

- [ ] **Task 4: Criar UserRepositoryPort (Porta OUT)** (AC: 3)
  - [ ] Criar interface `application/port/out/UserRepositoryPort.java`
  - [ ] Definir métodos retornando domain objects (`User`):
    ```java
    Optional<User> findByEmail(String email);
    User save(User user);
    Optional<User> findById(Long id);
    List<User> findAll();
    ```

- [ ] **Task 5: Criar UserJpaRepository** (AC: 4)
  - [ ] Criar `infrastructure/adapter/out/persistence/repository/UserJpaRepository.java`
  - [ ] Estender `JpaRepository<UserEntity, Long>`
  - [ ] Adicionar método: `Optional<UserEntity> findByEmail(String email);`

- [ ] **Task 6: Criar UserMapper com MapStruct** (AC: 7)
  - [ ] Criar `infrastructure/adapter/out/persistence/mapper/UserMapper.java`
  - [ ] Anotar com `@Mapper(componentModel = "spring")`
  - [ ] Definir métodos:
    ```java
    User toDomain(UserEntity entity);
    UserEntity toEntity(User domain);
    List<User> toDomainList(List<UserEntity> entities);
    ```

- [ ] **Task 7: Criar UserRepositoryAdapter** (AC: 5)
  - [ ] Criar `infrastructure/adapter/out/persistence/adapter/UserRepositoryAdapter.java`
  - [ ] Implementar `UserRepositoryPort`
  - [ ] Injetar `UserJpaRepository` e `UserMapper`
  - [ ] Implementar métodos delegando para JPA repository e convertendo via mapper:
    ```java
    @Override
    public Optional<User> findByEmail(String email) {
        return userJpaRepository.findByEmail(email)
            .map(userMapper::toDomain);
    }
    ```
  - [ ] Anotar com `@Component`

- [ ] **Task 8: Criar Teste de Integração** (AC: 8)
  - [ ] Criar `UserRepositoryAdapterTest.java` estendendo `IntegrationTestBase`
  - [ ] **Teste 1:** Salvar usuário e recuperar por email
  - [ ] **Teste 2:** Validar unique constraint - tentar criar usuário duplicado deve lançar `DataIntegrityViolationException`
  - [ ] **Teste 3:** Soft delete - setar status INACTIVE e validar que persiste

## Dev Notes

### Arquitetura Hexagonal - Camadas

Esta story implementa o **primeiro exemplo completo** do padrão hexagonal no projeto.

[Source: architecture/02-Arquitetura-de-Alto-Nível.md]

**Fluxo de Dados:**
```
Domain (User) ←→ Port OUT (UserRepositoryPort) ←→ Adapter (UserRepositoryAdapter)
                                                   ↓
                                        JPA Repository → Entity → PostgreSQL
```

**Princípios Críticos:**
- Domain Model (`User`) é POJO puro - SEM annotations Spring/JPA
- Port (`UserRepositoryPort`) usa domain objects
- Adapter (`UserRepositoryAdapter`) converte Entity ↔ Domain via MapStruct

### Nomenclatura snake_case (ADR-001)

[Source: architecture/adr-001-simplificacao-modelo-dados.md]

**Tabela:** `tb_usuario` (não `users` ou `user`)

**Mapeamento Completo:**
| Campo Java | Coluna DB |
|------------|-----------|
| `firstName` | `primeiro_nome` |
| `lastName` | `sobrenome` |
| `email` | `email` |
| `password` | `senha` |
| `role` | `funcao` |
| `mustChangePassword` | `deve_mudar_senha` |

### UserEntity - Implementação Completa

```java
package br.com.lalurecf.infrastructure.adapter.out.persistence.entity;

import br.com.lalurecf.domain.enums.UserRole;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "tb_usuario")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserEntity extends BaseEntity {

    @Column(name = "primeiro_nome", nullable = false)
    private String firstName;

    @Column(name = "sobrenome", nullable = false)
    private String lastName;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(name = "senha", nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(name = "funcao", nullable = false)
    private UserRole role;

    @Column(name = "deve_mudar_senha", nullable = false)
    private Boolean mustChangePassword = true;
}
```

### Domain Model User - Implementação

```java
package br.com.lalurecf.domain.model;

import br.com.lalurecf.domain.enums.Status;
import br.com.lalurecf.domain.enums.UserRole;
import lombok.*;

import java.time.LocalDateTime;

/**
 * Domain Model - Usuário do sistema.
 *
 * POJO puro sem dependências de frameworks (Spring/JPA).
 * Representa usuário no contexto de domínio.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Long id;
    private String firstName;
    private String lastName;
    private String email;
    private String password;
    private UserRole role;
    private Boolean mustChangePassword;
    private Status status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private String createdBy;
    private String updatedBy;
}
```

### MapStruct Configuration

**pom.xml:** Garantir que MapStruct está configurado corretamente (já feito em Story 1.1)

```xml
<dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct</artifactId>
    <version>1.5.5.Final</version>
</dependency>
<dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct-processor</artifactId>
    <version>1.5.5.Final</version>
    <scope>provided</scope>
</dependency>
```

**Mapper:**
```java
package br.com.lalurecf.infrastructure.adapter.out.persistence.mapper;

import br.com.lalurecf.domain.model.User;
import br.com.lalurecf.infrastructure.adapter.out.persistence.entity.UserEntity;
import org.mapstruct.Mapper;
import java.util.List;

@Mapper(componentModel = "spring")
public interface UserMapper {
    User toDomain(UserEntity entity);
    UserEntity toEntity(User domain);
    List<User> toDomainList(List<UserEntity> entities);
}
```

### Testing

**Teste de Integração:**

```java
@DisplayName("UserRepositoryAdapter - Testes de Integração")
class UserRepositoryAdapterTest extends IntegrationTestBase {

    @Autowired
    private UserRepositoryPort userRepository;

    @Test
    @DisplayName("Deve salvar usuário e recuperar por email")
    void shouldSaveAndFindUserByEmail() {
        // Arrange
        User user = User.builder()
            .firstName("João")
            .lastName("Silva")
            .email("joao@test.com")
            .password("hashed_password")
            .role(UserRole.CONTADOR)
            .mustChangePassword(true)
            .status(Status.ACTIVE)
            .build();

        // Act
        User saved = userRepository.save(user);
        Optional<User> found = userRepository.findByEmail("joao@test.com");

        // Assert
        assertThat(saved.getId()).isNotNull();
        assertThat(found).isPresent();
        assertThat(found.get().getFirstName()).isEqualTo("João");
    }

    @Test
    @DisplayName("Deve lançar exception ao criar usuário com email duplicado")
    void shouldThrowExceptionOnDuplicateEmail() {
        // Arrange
        User user1 = User.builder()
            .email("duplicate@test.com")
            .firstName("User")
            .lastName("One")
            .password("pass")
            .role(UserRole.ADMIN)
            .build();

        userRepository.save(user1);

        User user2 = user1.toBuilder()
            .id(null) // novo usuário
            .firstName("User Two")
            .build();

        // Act & Assert
        assertThatThrownBy(() -> userRepository.save(user2))
            .isInstanceOf(DataIntegrityViolationException.class);
    }

    @Test
    @DisplayName("Deve persistir soft delete (status INACTIVE)")
    void shouldPersistSoftDelete() {
        // Arrange
        User user = User.builder()
            .firstName("Delete")
            .lastName("Test")
            .email("delete@test.com")
            .password("pass")
            .role(UserRole.CONTADOR)
            .status(Status.ACTIVE)
            .build();

        User saved = userRepository.save(user);

        // Act - soft delete
        saved.setStatus(Status.INACTIVE);
        userRepository.save(saved);

        // Assert
        Optional<User> found = userRepository.findById(saved.getId());
        assertThat(found).isPresent();
        assertThat(found.get().getStatus()).isEqualTo(Status.INACTIVE);
    }
}
```

[Source: architecture/14-Estratégia-e-Padrões-de-Testes.md]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-25 | 1.0 | Story criada do Epic 01 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

**Model:** Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)
**Agent Type:** Developer (James)
**Date:** 2025-11-09

### Debug Log References

**Implementation:**
- All domain, application and infrastructure layers created following hexagonal architecture
- MapStruct mapper configured for entity-domain conversion
- UserEntity mapped to tb_usuario table following ADR-001 (snake_case)
- Integration tests created with TestContainers
- Soft delete and unique constraint validation working correctly

### Completion Notes

All 8 tasks completed successfully:

1. **UserRole Enum:** Created domain/enums/UserRole.java with ADMIN and CONTADOR roles
2. **User Domain Model:** Created domain/model/User.java as pure POJO with Lombok (@Data, @Builder)
3. **UserEntity:** Created JPA entity extending BaseEntity, mapped to tb_usuario with snake_case columns (primeiro_nome, sobrenome, senha, funcao, deve_mudar_senha)
4. **UserRepositoryPort:** Created port OUT interface in application layer working with domain objects
5. **UserJpaRepository:** Created Spring Data JPA repository with findByEmail custom query
6. **UserMapper:** Created MapStruct interface for bidirectional conversion (Entity ↔ Domain)
7. **UserRepositoryAdapter:** Created adapter implementing UserRepositoryPort, delegating to JPA repository and using mapper
8. **Integration Tests:** Created 4 test cases validating save/find, unique constraint, soft delete, and findAll

**Important Notes:**
- All acceptance criteria met
- Complete implementation of hexagonal architecture pattern (first full example in project)
- Domain layer pure (no Spring/JPA annotations)
- Port uses domain objects only
- Adapter converts Entity ↔ Domain via MapStruct
- Column naming follows ADR-001: snake_case (primeiro_nome, sobrenome, senha, funcao, deve_mudar_senha)
- Email has unique constraint at database level
- Soft delete pattern validated with Status.INACTIVE
- Audit fields automatically populated (inherited from BaseEntity)

**Hexagonal Architecture Flow:**
```
Domain (User) ←→ Port OUT (UserRepositoryPort) ←→ Adapter (UserRepositoryAdapter)
                                                   ↓
                                        UserJpaRepository → UserEntity → PostgreSQL
```

**Test Coverage:**
- 4 integration tests created
- All CRUD operations validated
- Unique constraint tested
- Soft delete tested
- TestContainers with PostgreSQL 15.5-alpine

### File List

**Created Files:**
- `src/main/java/br/com/lalurecf/domain/enums/UserRole.java` - Enum with ADMIN and CONTADOR roles
- `src/main/java/br/com/lalurecf/domain/model/User.java` - Pure domain model (POJO)
- `src/main/java/br/com/lalurecf/infrastructure/adapter/out/persistence/entity/UserEntity.java` - JPA entity extending BaseEntity
- `src/main/java/br/com/lalurecf/application/port/out/UserRepositoryPort.java` - Port OUT interface
- `src/main/java/br/com/lalurecf/infrastructure/adapter/out/persistence/repository/UserJpaRepository.java` - Spring Data repository
- `src/main/java/br/com/lalurecf/infrastructure/adapter/out/persistence/mapper/UserMapper.java` - MapStruct mapper
- `src/main/java/br/com/lalurecf/infrastructure/adapter/out/persistence/adapter/UserRepositoryAdapter.java` - Adapter implementation
- `src/test/java/br/com/lalurecf/infrastructure/adapter/out/persistence/adapter/UserRepositoryAdapterTest.java` - Integration tests (4 test cases)

**Database Schema Created (via JPA ddl-auto:update):**
Table: `tb_usuario`
- `id` BIGINT PRIMARY KEY
- `primeiro_nome` VARCHAR NOT NULL
- `sobrenome` VARCHAR NOT NULL
- `email` VARCHAR UNIQUE NOT NULL
- `senha` VARCHAR NOT NULL
- `funcao` VARCHAR NOT NULL (UserRole enum)
- `deve_mudar_senha` BOOLEAN NOT NULL DEFAULT TRUE
- `status` VARCHAR NOT NULL DEFAULT 'ACTIVE'
- `criado_em` TIMESTAMP NOT NULL
- `atualizado_em` TIMESTAMP NOT NULL
- `criado_por` VARCHAR
- `atualizado_por` VARCHAR

## QA Results

*Esta seção será preenchida pelo QA Agent após implementação.*
