# Story 3.1: Entidade ChartOfAccount (Plano de Contas) e Repository

## Status

**Draft** (2025-12-27)

---

## Story

**As a** desenvolvedor,
**I want** entidade ChartOfAccount com repository JPA implementando port,
**so that** possamos persistir contas contábeis de cada empresa por ano fiscal com estrutura plana.

---

## Acceptance Criteria

1. Entidade JPA `ChartOfAccountEntity` criada em `infrastructure/adapter/out/persistence/entity/` estendendo `BaseEntity`:
   - `@ManyToOne @JoinColumn(nullable=false) CompanyEntity company` (empresa dona da conta)
   - `@Column(nullable=false) String accountCode` (código da conta, ex: "1.1.01.001")
   - `@Column(nullable=false) String accountName` (nome da conta, ex: "Caixa")
   - `@Column(nullable=false) Integer fiscalYear` (ano fiscal, ex: 2024)
   - `@Enumerated(STRING) AccountType accountType` (ATIVO, PASSIVO, RECEITA, DESPESA, RESULTADO)
   - `@Column(precision=19, scale=2) BigDecimal openingBalance` (saldo inicial - opcional)

2. Enum `AccountType` criado:
   - ATIVO, PASSIVO, PATRIMONIO_LIQUIDO, RECEITA, DESPESA, CUSTO, RESULTADO

3. Constraint de unicidade: `@Table(uniqueConstraints = @UniqueConstraint(columnNames = {"company_id", "account_code", "fiscal_year"}))`
   - Garante que não existam contas duplicadas para mesma empresa + código + ano

4. Interface `ChartOfAccountRepositoryPort` criada em `application/port/out/`:
   - `ChartOfAccount save(ChartOfAccount account)`
   - `Optional<ChartOfAccount> findById(Long id)`
   - `List<ChartOfAccount> findByCompanyIdAndFiscalYear(Long companyId, Integer fiscalYear)`
   - `Optional<ChartOfAccount> findByCompanyIdAndAccountCodeAndFiscalYear(Long companyId, String accountCode, Integer fiscalYear)`
   - `void deleteById(Long id)`
   - `Page<ChartOfAccount> findByCompanyId(Long companyId, Pageable pageable)`

5. Interface `ChartOfAccountJpaRepository` criada estendendo `JpaRepository<ChartOfAccountEntity, Long>`:
   - `List<ChartOfAccountEntity> findByCompanyIdAndFiscalYear(Long companyId, Integer fiscalYear)`
   - `Optional<ChartOfAccountEntity> findByCompanyIdAndAccountCodeAndFiscalYear(Long companyId, String accountCode, Integer fiscalYear)`

6. Classe `ChartOfAccountRepositoryAdapter` implementa `ChartOfAccountRepositoryPort`

7. Model `ChartOfAccount` (domain) criado em `domain/model/` como POJO puro

8. Mapper MapStruct `ChartOfAccountMapper` criado

9. Teste de integração (TestContainers) valida:
   - Salvar conta e recuperar por company + fiscalYear
   - Unique constraint funciona (duplicata lança exception)
   - Buscar conta por company + accountCode + fiscalYear
   - Soft delete funciona corretamente
   - Listagem paginada por empresa

---

## Tasks / Subtasks

- [ ] Criar enum AccountType (AC: 2)
  - [ ] Criar enum com valores: ATIVO, PASSIVO, PATRIMONIO_LIQUIDO, RECEITA, DESPESA, CUSTO, RESULTADO
  - [ ] Adicionar em `domain/enums/`

- [ ] Criar entidade ChartOfAccountEntity (AC: 1, 3)
  - [ ] Criar entity estendendo BaseEntity
  - [ ] Adicionar relacionamento ManyToOne com CompanyEntity
  - [ ] Adicionar campos: accountCode, accountName, fiscalYear, accountType, openingBalance
  - [ ] Adicionar unique constraint (company_id, account_code, fiscal_year)
  - [ ] Configurar índices para performance

- [ ] Criar domain model ChartOfAccount (AC: 7)
  - [ ] Criar POJO puro em `domain/model/`
  - [ ] Incluir todos campos da entidade

- [ ] Criar ChartOfAccountRepositoryPort (AC: 4)
  - [ ] Criar interface em `application/port/out/`
  - [ ] Adicionar métodos: save, findById, findByCompanyIdAndFiscalYear, etc.

- [ ] Criar ChartOfAccountJpaRepository (AC: 5)
  - [ ] Estender JpaRepository
  - [ ] Adicionar query methods customizados

- [ ] Criar ChartOfAccountRepositoryAdapter (AC: 6)
  - [ ] Implementar ChartOfAccountRepositoryPort
  - [ ] Injetar ChartOfAccountJpaRepository
  - [ ] Implementar mapeamento entity/domain

- [ ] Criar ChartOfAccountMapper (AC: 8)
  - [ ] Criar interface MapStruct
  - [ ] Mapear ChartOfAccountEntity ↔ ChartOfAccount

- [ ] Criar teste de integração (AC: 9)
  - [ ] Configurar TestContainers
  - [ ] Testar save e findByCompanyIdAndFiscalYear
  - [ ] Testar unique constraint
  - [ ] Testar findByCompanyIdAndAccountCodeAndFiscalYear
  - [ ] Testar soft delete
  - [ ] Testar paginação

---

## Dev Notes

### Arquitetura

**Hexagonal Architecture (Ports & Adapters):**
```
Domain (core business logic)
  ↓
Application Layer (use cases + ports)
  ↓
Infrastructure Layer (adapters: JPA, REST, etc.)
```

### Estrutura de Diretórios

```
src/main/java/br/com/lalurecf/
├── domain/
│   ├── model/
│   │   └── ChartOfAccount.java (POJO puro)
│   └── enums/
│       └── AccountType.java
├── application/
│   └── port/
│       └── out/
│           └── ChartOfAccountRepositoryPort.java
└── infrastructure/
    └── adapter/
        └── out/
            └── persistence/
                ├── entity/
                │   └── ChartOfAccountEntity.java
                ├── repository/
                │   └── ChartOfAccountJpaRepository.java
                └── ChartOfAccountRepositoryAdapter.java
```

### Exemplo de Código

**ChartOfAccountEntity.java:**
```java
@Entity
@Table(
    name = "chart_of_account",
    uniqueConstraints = @UniqueConstraint(columnNames = {"company_id", "account_code", "fiscal_year"})
)
public class ChartOfAccountEntity extends BaseEntity {

    @ManyToOne
    @JoinColumn(name = "company_id", nullable = false)
    private CompanyEntity company;

    @Column(name = "account_code", nullable = false)
    private String accountCode;

    @Column(name = "account_name", nullable = false)
    private String accountName;

    @Column(name = "fiscal_year", nullable = false)
    private Integer fiscalYear;

    @Enumerated(EnumType.STRING)
    @Column(name = "account_type", nullable = false)
    private AccountType accountType;

    @Column(name = "opening_balance", precision = 19, scale = 2)
    private BigDecimal openingBalance;

    // Getters and setters
}
```

**AccountType.java:**
```java
public enum AccountType {
    ATIVO,
    PASSIVO,
    PATRIMONIO_LIQUIDO,
    RECEITA,
    DESPESA,
    CUSTO,
    RESULTADO
}
```

### Padrões de Código

- **Nomenclatura**: seguir convenções Java (camelCase para variáveis, PascalCase para classes)
- **Validações**: validações de negócio nos use cases, constraints no banco
- **Testes**: usar AssertJ para assertions fluentes
- **TestContainers**: PostgreSQL 15.5 real em container Docker

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-27 | 1.0 | Story criada a partir do Epic 3 | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used
*A ser preenchido durante desenvolvimento*

### Debug Log References
*A ser preenchido durante desenvolvimento*

### Completion Notes List
*A ser preenchido durante desenvolvimento*

### File List
*A ser preenchido durante desenvolvimento*

---

## QA Results
*A ser preenchido após revisão de QA*
