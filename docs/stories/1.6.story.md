# Story 1.6: Endpoint de Login (Autenticação)

## Status

**Done**

## Story

**Como** usuário (ADMIN ou CONTADOR),
**Eu quero** fazer login com email e senha,
**Para que** eu receba tokens JWT (access + refresh) para acessar o sistema.

## Acceptance Criteria

1. Controller `AuthController` criado em `infrastructure/adapter/in/rest/` com endpoint `POST /api/v1/auth/login`
2. DTO `LoginRequest` criado: `email` (obrigatório), `password` (obrigatório)
3. DTO `LoginResponse` criado: `accessToken`, `refreshToken`, `email`, `firstName`, `lastName`, `role`, `mustChangePassword`
4. Use case `AuthenticateUserUseCase` (port in) e implementação `AuthService` criados:
   - Busca usuário por email
   - Valida senha usando BCryptPasswordEncoder
   - Gera access token e refresh token
   - Retorna tokens + dados do usuário + flag `mustChangePassword`
5. Response retorna status 200 OK com tokens se credenciais válidas
6. Response retorna status 401 Unauthorized com mensagem "Credenciais inválidas" se email ou senha incorretos
7. Response retorna status 400 Bad Request se campos obrigatórios ausentes (validação Bean Validation)
8. Teste de API valida login bem-sucedido retorna tokens válidos e dados do usuário
9. Teste valida login com senha incorreta retorna 401
10. Teste valida login com email inexistente retorna 401

## Tasks / Subtasks

- [ ] **Task 1: Criar DTOs de Autenticação** (AC: 2, 3)
  - [ ] Criar `infrastructure/dto/auth/LoginRequest.java`:
    ```java
    @NotBlank String email
    @NotBlank String password
    ```
  - [ ] Criar `infrastructure/dto/auth/LoginResponse.java`:
    ```java
    String accessToken
    String refreshToken
    String email
    String firstName
    String lastName
    UserRole role
    Boolean mustChangePassword
    ```

- [ ] **Task 2: Criar Port IN - AuthenticateUserUseCase** (AC: 4)
  - [ ] Criar interface `application/port/in/AuthenticateUserUseCase.java`
  - [ ] Definir método: `LoginResponse authenticate(LoginRequest request)`

- [ ] **Task 3: Criar AuthService** (AC: 4)
  - [ ] Criar `application/service/AuthService.java`
  - [ ] Implementar `AuthenticateUserUseCase`
  - [ ] Injetar `UserRepositoryPort`, `PasswordEncoder`, `JwtTokenProvider`
  - [ ] Implementar lógica de autenticação:
    - Buscar usuário por email
    - Validar senha com BCrypt
    - Gerar tokens
    - Montar response

- [ ] **Task 4: Criar Exception Customizada**
  - [ ] Criar `domain/exception/InvalidCredentialsException.java`

- [ ] **Task 5: Criar AuthController** (AC: 1, 5, 6, 7)
  - [ ] Criar `infrastructure/adapter/in/rest/AuthController.java`
  - [ ] Anotar com `@RestController`, `@RequestMapping("/api/v1/auth")`
  - [ ] Endpoint `POST /login`:
    - `@Valid LoginRequest` no body
    - Chamar `AuthenticateUserUseCase`
    - Retornar `ResponseEntity<LoginResponse>`
  - [ ] Tratar exceptions: `InvalidCredentialsException` → 401

- [ ] **Task 6: Criar Exception Handler Global** (AC: 6, 7)
  - [ ] Criar `infrastructure/exception/GlobalExceptionHandler.java`
  - [ ] Anotar com `@RestControllerAdvice`
  - [ ] Adicionar handler para `InvalidCredentialsException` → 401
  - [ ] Adicionar handler para `MethodArgumentNotValidException` → 400
  - [ ] Retornar ErrorResponse RFC 7807 format

- [ ] **Task 7: Criar Testes de Integração** (AC: 8, 9, 10)
  - [ ] Criar `AuthControllerIntegrationTest.java`
  - [ ] Seed: criar usuário de teste no banco
  - [ ] Testar login bem-sucedido: validar tokens e dados retornados
  - [ ] Testar login com senha incorreta: validar 401
  - [ ] Testar login com email inexistente: validar 401
  - [ ] Testar login com campos vazios: validar 400

## Dev Notes

### Contexto da Arquitetura

Esta story implementa o **primeiro Use Case completo** seguindo arquitetura hexagonal.

[Source: architecture/02-Arquitetura-de-Alto-Nível.md]

**Fluxo:**
```
HTTP POST → Controller (Adapter IN) → Use Case (Port IN) → Service (Application)
                                                            ↓
                                          Repository Port (Port OUT) → Adapter OUT
```

### DTOs e Validação

[Source: architecture/15-Segurança.md#Validação-de-Entrada]

**Regras:**
- TODAS entradas externas DEVEM ser validadas
- Bean Validation 3.0.2 + Hibernate Validator 8.0.1
- Whitelist approach

**LoginRequest:**
```java
package br.com.lalurecf.infrastructure.dto.auth;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {

    @NotBlank(message = "Email é obrigatório")
    @Email(message = "Email deve ser válido")
    private String email;

    @NotBlank(message = "Senha é obrigatória")
    private String password;
}
```

**LoginResponse:**
```java
package br.com.lalurecf.infrastructure.dto.auth;

import br.com.lalurecf.domain.enums.UserRole;
import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class LoginResponse {
    private String accessToken;
    private String refreshToken;
    private String email;
    private String firstName;
    private String lastName;
    private UserRole role;
    private Boolean mustChangePassword;
}
```

### AuthService - Implementação

```java
package br.com.lalurecf.application.service;

import br.com.lalurecf.application.port.in.AuthenticateUserUseCase;
import br.com.lalurecf.application.port.out.UserRepositoryPort;
import br.com.lalurecf.domain.exception.InvalidCredentialsException;
import br.com.lalurecf.domain.model.User;
import br.com.lalurecf.infrastructure.dto.auth.LoginRequest;
import br.com.lalurecf.infrastructure.dto.auth.LoginResponse;
import br.com.lalurecf.infrastructure.security.JwtTokenProvider;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Slf4j
public class AuthService implements AuthenticateUserUseCase {

    private final UserRepositoryPort userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenProvider jwtTokenProvider;

    @Override
    @Transactional(readOnly = true)
    public LoginResponse authenticate(LoginRequest request) {
        log.debug("Autenticando usuário: {}", request.getEmail());

        User user = userRepository.findByEmail(request.getEmail())
            .orElseThrow(() -> new InvalidCredentialsException("Credenciais inválidas"));

        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            log.warn("Tentativa de login com senha incorreta: {}", request.getEmail());
            throw new InvalidCredentialsException("Credenciais inválidas");
        }

        String accessToken = jwtTokenProvider.generateAccessToken(user.getEmail(), user.getRole());
        String refreshToken = jwtTokenProvider.generateRefreshToken(user.getEmail());

        log.info("Login bem-sucedido: {} (role: {})", user.getEmail(), user.getRole());

        return LoginResponse.builder()
            .accessToken(accessToken)
            .refreshToken(refreshToken)
            .email(user.getEmail())
            .firstName(user.getFirstName())
            .lastName(user.getLastName())
            .role(user.getRole())
            .mustChangePassword(user.getMustChangePassword())
            .build();
    }
}
```

### AuthController - Implementação

```java
package br.com.lalurecf.infrastructure.adapter.in.rest;

import br.com.lalurecf.application.port.in.AuthenticateUserUseCase;
import br.com.lalurecf.infrastructure.dto.auth.LoginRequest;
import br.com.lalurecf.infrastructure.dto.auth.LoginResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
@Tag(name = "Authentication", description = "Endpoints de autenticação")
public class AuthController {

    private final AuthenticateUserUseCase authenticateUserUseCase;

    @PostMapping("/login")
    @Operation(summary = "Login", description = "Autenticar usuário com email e senha")
    public ResponseEntity<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
        LoginResponse response = authenticateUserUseCase.authenticate(request);
        return ResponseEntity.ok(response);
    }
}
```

### GlobalExceptionHandler - Implementação

```java
package br.com.lalurecf.infrastructure.exception;

import br.com.lalurecf.domain.exception.InvalidCredentialsException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(InvalidCredentialsException.class)
    public ResponseEntity<ErrorResponse> handleInvalidCredentials(InvalidCredentialsException ex) {
        log.warn("Credenciais inválidas: {}", ex.getMessage());
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.UNAUTHORIZED.value())
            .error("Unauthorized")
            .message(ex.getMessage())
            .build();
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationErrors(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.BAD_REQUEST.value())
            .error("Validation Error")
            .message("Erro de validação")
            .validationErrors(errors)
            .build();
        return ResponseEntity.badRequest().body(error);
    }
}
```

### Testing

**Teste de Integração:**
```java
@DisplayName("AuthController - Login Integration Tests")
class AuthControllerIntegrationTest extends IntegrationTestBase {

    @BeforeEach
    void setup() {
        // Seed usuário de teste
        User user = User.builder()
            .email("test@test.com")
            .password(passwordEncoder.encode("password123"))
            .firstName("Test")
            .lastName("User")
            .role(UserRole.ADMIN)
            .status(Status.ACTIVE)
            .build();
        userRepository.save(user);
    }

    @Test
    @DisplayName("Deve retornar tokens válidos em login bem-sucedido")
    void shouldReturnValidTokensOnSuccessfulLogin() {
        LoginRequest request = new LoginRequest("test@test.com", "password123");

        ResponseEntity<LoginResponse> response = restTemplate.postForEntity(
            "/api/v1/auth/login", request, LoginResponse.class);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getAccessToken()).isNotNull();
        assertThat(response.getBody().getEmail()).isEqualTo("test@test.com");
    }

    @Test
    @DisplayName("Deve retornar 401 com senha incorreta")
    void shouldReturn401WithWrongPassword() {
        LoginRequest request = new LoginRequest("test@test.com", "wrongpassword");

        ResponseEntity<ErrorResponse> response = restTemplate.postForEntity(
            "/api/v1/auth/login", request, ErrorResponse.class);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
    }
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-25 | 1.0 | Story criada do Epic 01 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

**Model:** Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)
**Agent Type:** Developer (James)
**Date:** 2025-11-09

### Debug Log References

**Implementation:**
- Complete implementation of first Use Case following hexagonal architecture
- DTOs created with Bean Validation annotations
- Port IN created in application layer
- Service created implementing use case
- Domain exception created for invalid credentials
- Controller created as Adapter IN
- Global exception handler created for standardized error responses
- Integration tests created with full coverage (5 test cases)
- All authentication flows validated

### Completion Notes

All 7 tasks completed successfully:

1. **Authentication DTOs:** Created LoginRequest (with @NotBlank and @Email validations) and LoginResponse (with tokens and user data)
2. **AuthenticateUserUseCase:** Created Port IN interface in application layer defining authenticate contract
3. **AuthService:** Created service implementing use case with user lookup, BCrypt password validation, JWT token generation, and response building
4. **InvalidCredentialsException:** Created domain exception for authentication failures
5. **AuthController:** Created REST controller with POST /api/v1/auth/login endpoint using @Valid for Bean Validation
6. **GlobalExceptionHandler:** Created @RestControllerAdvice with handlers for InvalidCredentialsException (401) and MethodArgumentNotValidException (400) returning ErrorResponse
7. **Integration Tests:** Created 5 test cases covering successful login, wrong password, nonexistent email, empty fields, and invalid email format

**Important Notes:**
- All acceptance criteria met
- First complete Use Case implementation following hexagonal architecture
- Clean separation: Controller (Adapter IN) → Use Case (Port IN) → Service (Application) → Repository (Port OUT)
- DTOs in infrastructure layer, domain models remain pure
- Bean Validation working with @Valid in controller
- BCrypt password validation using strength 12
- JWT tokens generated with 15min (access) and 7 days (refresh) expiration
- Error responses follow RFC 7807 format
- Global exception handling centralizes error responses
- Login endpoint publicly accessible (no authentication required)
- Successful login returns 200 OK with tokens and user data
- Invalid credentials return 401 Unauthorized
- Validation errors return 400 Bad Request with field-level errors

**Use Case Flow:**
```
POST /api/v1/auth/login (AuthController - Adapter IN)
    ↓
authenticate(LoginRequest) (AuthenticateUserUseCase - Port IN)
    ↓
AuthService.authenticate() (Application Service)
    ↓ findByEmail()
UserRepositoryPort (Port OUT) → UserRepositoryAdapter → JPA
    ↓ validates password with BCrypt
    ↓ generates JWT tokens
    ↓ builds LoginResponse
    ↓
200 OK with tokens + user data
```

**Error Handling:**
- User not found → InvalidCredentialsException → 401 Unauthorized
- Wrong password → InvalidCredentialsException → 401 Unauthorized
- Empty/invalid fields → MethodArgumentNotValidException → 400 Bad Request

**Test Coverage:**
- 5 integration tests using TestRestTemplate
- All authentication scenarios covered
- Seed data created in @BeforeEach
- BCrypt password encoding validated
- Response DTOs fully validated

### File List

**Created Files:**
- `src/main/java/br/com/lalurecf/infrastructure/dto/auth/LoginRequest.java` - Login request DTO with Bean Validation
- `src/main/java/br/com/lalurecf/infrastructure/dto/auth/LoginResponse.java` - Login response DTO with tokens and user data
- `src/main/java/br/com/lalurecf/application/port/in/AuthenticateUserUseCase.java` - Port IN interface for authentication use case
- `src/main/java/br/com/lalurecf/domain/exception/InvalidCredentialsException.java` - Domain exception for invalid credentials
- `src/main/java/br/com/lalurecf/application/service/AuthService.java` - Service implementing authentication use case
- `src/main/java/br/com/lalurecf/infrastructure/adapter/in/rest/AuthController.java` - REST controller with login endpoint
- `src/main/java/br/com/lalurecf/infrastructure/exception/ErrorResponse.java` - Standardized error response DTO
- `src/main/java/br/com/lalurecf/infrastructure/exception/GlobalExceptionHandler.java` - Global exception handler with @RestControllerAdvice
- `src/test/java/br/com/lalurecf/infrastructure/adapter/in/rest/AuthControllerIntegrationTest.java` - Integration tests (5 test cases)

**API Endpoint:**
- **POST /api/v1/auth/login** - Authenticate user with email and password

## QA Results

*Esta seção será preenchida pelo QA Agent após implementação.*
