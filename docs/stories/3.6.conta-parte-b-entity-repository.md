# Story 3.6: Entidade ContaParteB (Conta da Parte B e-Lalur/e-Lacs) e Repository

**Como** desenvolvedor,
**Eu quero** entidade ContaParteB relacionada a Company com campos para e-Lalur/e-Lacs,
**Para que** possamos persistir Contas da Parte B específicas de IRPJ/CSLL com vigência temporal e saldo inicial.

## Acceptance Criteria

1. Entidade JPA `ContaParteBEntity` criada estendendo `BaseEntity`:
   - `@ManyToOne @JoinColumn(nullable=false) CompanyEntity company` (empresa dona do cadastro)
   - `@Column(nullable=false) String codigoConta` (código da conta Parte B, ex: "4.01.01")
   - `@Column(nullable=false, length=1000) String descricao` (descrição da conta)
   - `@Column(nullable=false) Integer anoBase` (ano base de criação/referência)
   - `@Column(nullable=false) LocalDate dataVigenciaInicio` (data início de vigência)
   - `@Column LocalDate dataVigenciaFim` (data fim de vigência - nullable, null = vigente)
   - `@Enumerated(STRING) TipoTributo tipoTributo` (IRPJ, CSLL, AMBOS)
   - `@Column(precision=19, scale=2) BigDecimal saldoInicial` (saldo inicial da conta)
   - `@Enumerated(STRING) TipoSaldo tipoSaldo` (DEVEDOR, CREDOR)
2. Enums criados:
   - `TipoTributo`: IRPJ, CSLL, AMBOS
   - `TipoSaldo`: DEVEDOR, CREDOR
3. Constraint de unicidade: `@Table(uniqueConstraints = @UniqueConstraint(columnNames = {"company_id", "codigo_conta", "ano_base"}))`
4. Interface `ContaParteBRepositoryPort` criada em `application/port/out/`:
   - `ContaParteB save(ContaParteB conta)`
   - `Optional<ContaParteB> findById(Long id)`
   - `List<ContaParteB> findByCompanyIdAndAnoBase(Long companyId, Integer anoBase)`
   - `Optional<ContaParteB> findByCompanyIdAndCodigoContaAndAnoBase(Long companyId, String codigoConta, Integer anoBase)`
   - `Page<ContaParteB> findByCompanyId(Long companyId, Pageable pageable)`
5. Interface `ContaParteBJpaRepository` criada estendendo `JpaRepository<ContaParteBEntity, Long>`:
   - `List<ContaParteBEntity> findByCompanyIdAndAnoBase(Long companyId, Integer anoBase)`
   - `Optional<ContaParteBEntity> findByCompanyIdAndCodigoContaAndAnoBase(Long companyId, String codigoConta, Integer anoBase)`
6. Classe `ContaParteBRepositoryAdapter` implementa `ContaParteBRepositoryPort`
7. Model `ContaParteB` (domain) criado em `domain/model/` como POJO puro
8. Mapper MapStruct `ContaParteBMapper` criado
9. Teste de integração valida:
   - Salvar conta Parte B com todos campos e recuperar por company + anoBase
   - Unique constraint funciona
   - Buscar conta por company + codigoConta + anoBase
   - Soft delete funciona
   - Listagem paginada por empresa
   - Campos tipoTributo e tipoSaldo são persistidos corretamente

## Technical Notes

- **Separação entre contas contábeis e fiscais**: ContaParteB não está no plano de contas contábil
- **Vigência temporal**: Contas podem ter período de validade (comum em legislação fiscal)
- **Tipo tributo flexível**: Conta pode ser específica de IRPJ, CSLL ou aplicável a ambos
- **Saldo inicial configurável**: Importante para carry-forward de exercícios anteriores
- **Versionamento anual**: anoBase permite estrutura diferente por ano fiscal

## Definition of Done

- [ ] Entidade JPA criada com todos os campos
- [ ] Enums TipoTributo e TipoSaldo criados
- [ ] Repository port e adapter implementados
- [ ] Domain model criado
- [ ] Mapper MapStruct funcionando
- [ ] Testes de integração passando (TestContainers)
- [ ] Code review aprovado
- [ ] Merge em develop
